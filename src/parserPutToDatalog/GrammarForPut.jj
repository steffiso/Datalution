/**
 * JavaCC template file created by SF JavaCC plugin 1.5.28+ wizard for JavaCC 1.5.0+
 */options{  static = false;}PARSER_BEGIN(ParserForPut)package parserPutToDatalog;import java.io.IOException;import datastore.Database;import java.util.ArrayList;import java.util.InputMismatchException;import com.google.appengine.api.datastore.Entity;import datastore.Schema;import java.util.Date;import com.google.appengine.api.datastore.KeyFactory;public class ParserForPut{  private static int schemaVersion = 0;  private static ArrayList < String > attributes = null;  private static int counter = 0;  private static int length = 0;  private static int ts = 0;  private static boolean hasTS = false;  private static Database db = new Database();  private static void getSchema(String kind, int number) throws InputMismatchException  {    Schema schema = null;    if (number == 0)    {      schema = db.getLatestSchema(kind);    }    else schema = db.getSchema(kind, number);    if (schema != null)    {      attributes = schema.getAttributes();      length = attributes.size();      schemaVersion = schema.getVersion();    }  }}PARSER_END(ParserForPut)SKIP :{  " "| "\r"| "\t"| "\n"}TOKEN : /* Zeichen */{  < marks : "\"" >| < put : "put" >| < open : "{" >| < end : "}" >| < punkt : ":" >| < nullValue : "null" >| < string :    (      "'" (~[ "'" ])* "'"    )  |    (      "\"" (~[ "\"" ])* "\""    ) >| < number :    (< digit >)+    (      "." (< digit >)+    )? >| < digit : [ "0"-"9" ] >| < kindValue : < nameValue > (< nameValue >)* >| < nameValue :    [ "a"-"z" ]  | [ "A"-"Z" ]  | "_" >}Entity start(Database db, String username) throws InputMismatchException :{  Entity value = null;  counter = 0;  this.db = db;  hasTS = false;  schemaVersion = 0;  attributes = null;  length = 0;  ts = 0;}{  value = getEntity(username) < EOF >  {    return value;  }}Entity getEntity(String username) throws InputMismatchException :{  Token kind = null;  Token schemaToken = null;  Entity value = null;  boolean testOverflow = false;
  int newTS = 0;
  counter = 0;}{  (< put >  {    testOverflow = true;  }  )? (kind = < kindValue >) (schemaToken = < number >)?  {    if (schemaToken != null && testOverflow == false)    {      schemaVersion = Integer.parseInt(schemaToken.toString());      getSchema(kind.toString(), schemaVersion);
      ts = db.getLatestTimestamp(kind.toString(), username);
      newTS = ts + 1;    }    else if (schemaToken != null && testOverflow == true)    {      throw new InputMismatchException("no numbers for value of kind allowed");    }    else    {      getSchema(kind.toString(), 0);
      ts = db.getLatestTimestamp(kind.toString(), username);
      newTS = ts + 1;
    }    if (attributes == null)    {      throw new InputMismatchException("no info for schema of " + kind.toString() + " found");    }  }  "("  (    value = listOfValues    (      new Entity      (        kind.toString()+ schemaVersion, username+ Integer.toString(newTS), KeyFactory.createKey        (          kind.toString(), username        )      )    )  )?  ")" (".")?  {    if (value == null) throw new InputMismatchException("no attributes for " + kind.toString());    value.setProperty("ts", Integer.toString(newTS));    return value;  }}Entity listOfValues(Entity value) :{  Token valueOfToken = null;  Entity valueOfOtherToken = null;  String valueOne = "";  boolean isTS = false;  String name = null;  boolean nullvalue = false;  int numbers = 0;}{  (    valueOfToken = < string >  | valueOfToken = < number >  | valueOfToken = < nullValue >  )  {    if (counter < length)    {      if (valueOfToken.kind == string)      {        name = valueOfToken.toString();        name = name.substring(1, name.length() - 1);      }      else if (valueOfToken.kind == nullValue)      {        nullvalue = true;      }      else numbers = Integer.parseInt(valueOfToken.toString());      String attributename = attributes.get(counter);      valueOne = attributename.substring(1, attributename.length());      counter++;    }    else if (counter == length)
    {
//      if (!(valueOfToken.kind == string))//      {//        isTS = true;//        hasTS = true;//        ts = Integer.parseInt(valueOfToken.toString());//      }
      counter++;
    }
        else    {      counter++;      return null;    }  }  (    ","    (      valueOfOtherToken = listOfValues(value)    )  )*  {    String nullValues = "";    if (valueOfOtherToken != null)    { /*if (counter < length) { for (int i = counter; i < length; i++) { String attributename = attributes.get(i); name = null; valueOfOtherToken.setProperty(attributename, null); } }*/      value = valueOfOtherToken;      if (name != null) value.setProperty(valueOne, name);      else if (nullvalue) value.setProperty(valueOne, null);
      else if (valueOne == "")      {      }      else value.setProperty(valueOne, numbers);      return value;    }    else    {      if (name != null) value.setProperty(valueOne, name);      else if (nullvalue) value.setProperty(valueOne, null);
      else if (valueOne == "")
      {
      }      else value.setProperty(valueOne, numbers);      return value;    }  }}