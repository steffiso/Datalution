/**
 * JavaCC template file created by SF JavaCC plugin 1.5.28+ wizard for JavaCC 1.5.0+
 */options{  static = false;}PARSER_BEGIN(ParserQueryToDatalogToJava)package parserQueryToDatalogToJava;import java.util.ArrayList;import java.io.StringReader;import datastore.Database;import datastore.Schema;import datalog.Rule;import parserRuletoJava.ParserRuleToJava;import java.util.InputMismatchException;import java.io.IOException;
import java.util.Date;public class ParserQueryToDatalogToJava{  private String kindStr;  private String idStr;  private String rulesStr;  private static ArrayList < Rule > rules = new ArrayList < Rule > ();  private static Database db;  public String getKind()  {    return kindStr;  }  public String getId()  {    return idStr;  }  public String getRules()  {    return rulesStr;  }  private static ArrayList < String > getCurrentSchema(String kind) throws InputMismatchException, IOException  {    Schema currentSchema = db.getLatestSchema(kind);    if (currentSchema != null) return currentSchema.getAttributes();    else return null;  }  private static String schemaToString(ArrayList < String > schema)  {    String schemaStr = "";    for (String s : schema)    {      schemaStr = schemaStr + s + ",";    }    schemaStr = schemaStr.substring(0, schemaStr.length() - 1);    return schemaStr;  }  private static ArrayList < String > addAttributeNr(ArrayList < String > schema, int nr, String copiedAttr)  {    ArrayList < String > changedSchema = new ArrayList < String > ();    for (String s : schema)    {      if (!s.equals("null"))      {        if (s.equals(copiedAttr)) changedSchema.add(s + "2");        else changedSchema.add(s + Integer.toString(nr));      }      else changedSchema.add(s);    }    return changedSchema;  }  private static int getCurrentSchemaVersion(String kind) throws IOException  {    int currentSchemaVersion = db.getLatestSchemaVersion(kind);    return currentSchemaVersion;  }  private static ArrayList < String > getNewSchemaDelete(String kind, String value) throws InputMismatchException, IOException  {    ArrayList < String > currentSchema = getCurrentSchema(kind);    if (currentSchema == null)    {      throw new InputMismatchException("no info for schema of " + kind + " found");    }    else    {      ArrayList < String > tempNewSchema = new ArrayList < String > ();      for (String attribute : currentSchema)      {        if (!attribute.equals("?" + value)) tempNewSchema.add(attribute);      }      return tempNewSchema;    }  }  private static ArrayList < String > getNewSchemaAdd(String kind, String value) throws InputMismatchException, IOException  {    ArrayList < String > currentSchema = getCurrentSchema(kind);    if (currentSchema == null)    {      throw new InputMismatchException("no info for schema of " + kind + " found");    }    else    {      currentSchema.add(value);      return currentSchema;    }  }  private static void saveCurrentSchema(String kind, ArrayList < String > newSchema) throws InputMismatchException, IOException  {    ArrayList < String > currentSchema = getCurrentSchema(kind);    if (currentSchema == null)    {      throw new InputMismatchException("no info for schema of " + kind + " found");    }    else    {      if (!currentSchema.equals(newSchema))      {        db.saveCurrentSchema(kind, newSchema);      }    }  }  private static String getResidualRules(String kind) throws InputMismatchException, IOException  {    String value = null;    ArrayList < String > schema = getCurrentSchema(kind);    if (schema == null)    {      throw new InputMismatchException("no info for schema of " + kind + " found");    }    else    {      int currentVersion = getCurrentSchemaVersion(kind);      ArrayList < String > secondSchema = new ArrayList < String > ();      secondSchema.addAll(schema);      for (int i = 0; i < secondSchema.size(); i++)      {        String s = secondSchema.get(i);        if (!s.equals("?id"))        {          secondSchema.set(i, s + "2");        }      }      value = "legacy" + kind + currentVersion + "(?id,?ts):-" + kind + currentVersion + "(" + schemaToString(schema) + ",?ts)," + kind + currentVersion + "(" + schemaToString(secondSchema) + ",?nts), ?ts < ?nts.\n" + "latest" + kind + currentVersion + "(?id,?ts):-" + kind + currentVersion + "(" + schemaToString(schema) + ",?ts), not legacy" + kind + currentVersion + "(?id,?ts).\n";      return value;    }  }  private static String getTimestamp() throws IOException  {    Date d = new Date();
    String timestamp = "'" + d.toString() + "'";
    return timestamp;  }  public ArrayList < String > getSchema(String kind, int schemaNumber) throws InputMismatchException, IOException  {    Schema currentSchema = db.getSchema(kind, schemaNumber);    if (currentSchema != null) return currentSchema.getAttributes();    else    {      throw new InputMismatchException("no info for schema of " + kind + " found");    }  }  public String getAttributeName(String kind, int schemaNumber, int pos) throws InputMismatchException, IOException  {    Schema currentSchema = db.getSchema(kind, schemaNumber);    if (currentSchema != null)    {      ArrayList < String > attributes = currentSchema.getAttributes();      String value = attributes.get(pos);      return value;    }    else    {      throw new InputMismatchException("no info for schema of " + kind + " found");    }  }  private static boolean propertyExists(String kind, String value) throws InputMismatchException, IOException  {    ArrayList < String > currentSchema = getCurrentSchema(kind);    if (currentSchema == null)    {      throw new InputMismatchException("no info for schema of " + kind + " found");    }    else    {      return currentSchema.contains("?" + value);    }  }}PARSER_END(ParserQueryToDatalogToJava)SKIP :{  " "| "\r"| "\t"| "\n"}TOKEN :{  < get : "get" >| < add : "add" >| < delete : "delete" >| < copy : "copy" >| < move : "move" >| < string : "\"" (~[ "\"" ])* "\"" >| < nullValue : "null" >| < number :    (< digit >)+    (      "." (< digit >)+    )? >| < digit : [ "0"-"9" ] >| < name : < nameValue > (< nameValue >)* >| < nameValue :    [ "a"-"z" ]  | [ "A"-"Z" ]  | "_" >}String getDatalogRules(Database db) throws InputMismatchException, IOException, parserRuletoJava.ParseException :{  String value = null;  this.db = db;}{  value = start() < EOF >  {    return value;  }}ArrayList < Rule > getJavaRules(Database db) throws InputMismatchException, IOException, parserRuletoJava.ParseException :{  String value = null;  this.db = db;}{  value = start() < EOF >  {    rulesStr = value;    return rules;  }}String start() throws InputMismatchException, IOException, parserRuletoJava.ParseException :{  String value = null;  rules = new ArrayList < Rule > ();}{  (    value = get()  | value = add()  | value = delete()  | value = copy()  | value = move()  )  {    return value;  }}String get() throws InputMismatchException, IOException, parserRuletoJava.ParseException :{  Token kindToken = null;  Token idToken = null;  Token propertyToken = null;}{  < get > kindToken = < name > "." propertyToken = < name > "="  (    idToken = < string >  | idToken = < number >  )  {    if (!propertyToken.toString().equals("id")) throw new InputMismatchException("only id for get");    String kind = kindToken.toString();    String id;    if (idToken.kind == string)    {      id = idToken.toString();      id = id.substring(1, id.length() - 1);      id = "'" + id + "'";    }    else id = idToken.toString();    kindStr = kind;    idStr = id;    ArrayList < String > schema = getCurrentSchema(kind);    if (schema == null)    {      throw new InputMismatchException("no info for schema of " + kind + " found");    }    int currentVersion = getCurrentSchemaVersion(kind);    String residualRules = getResidualRules(kind);    String headRule = "get" + kind + currentVersion + "(" + schemaToString(schema) + ",?ts):-" + kind + currentVersion + "(" + schemaToString(schema) + ",?ts), latest" + kind + currentVersion + "(?id,?ts),?id=" + id + ".\n";    rules.addAll((new ParserRuleToJava(new StringReader(residualRules))).start());    rules.addAll((new ParserRuleToJava(new StringReader(headRule))).parseHeadRules());    return residualRules + headRule;  }}String add() throws InputMismatchException, IOException, parserRuletoJava.ParseException :{  Token kindToken = null;  Token propertyToken = null;  Token valueToken = null;}{  < add > kindToken = < name > "." propertyToken = < name > "="  (    valueToken = < string >  | valueToken = < number >  | valueToken = < nullValue >  )  {    String propertyName = propertyToken.toString();    String propertyValue;    if (valueToken.kind == string)    {      propertyValue = valueToken.toString();      propertyValue = propertyValue.substring(1, propertyValue.length() - 1);      propertyValue = "'" + propertyValue + "'";    }    else propertyValue = valueToken.toString();    String kind = kindToken.toString();    ArrayList < String > currentSchema = getCurrentSchema(kind);    if (currentSchema == null)    {      throw new InputMismatchException("no info for schema of " + kind + " found");    }    if (propertyExists(kind, propertyName))    {      throw new InputMismatchException("attribute for " + kind + " already exists");    }    ArrayList < String > newSchema = getNewSchemaAdd(kind, "?" + propertyName);    int currentSchemaVersion = getCurrentSchemaVersion(kind);    int newSchemaVersion = currentSchemaVersion + 1;    String residualRules = getResidualRules(kind);    String headRules = kind + newSchemaVersion + "(" + schemaToString(getNewSchemaAdd(kind, propertyValue)) + "," + getTimestamp() + "):-" + kind + currentSchemaVersion + "(" + schemaToString(currentSchema) + ",?ts), latest" + kind + currentSchemaVersion + "(?id,?ts).\n";    saveCurrentSchema(kind, newSchema);    rules.addAll((new ParserRuleToJava(new StringReader(residualRules))).start());    rules.addAll((new ParserRuleToJava(new StringReader(headRules))).parseHeadRules());    return residualRules + headRules;  }}String delete() throws InputMismatchException, IOException, parserRuletoJava.ParseException :{  Token kindToken = null;  Token propertyToken = null;}{  < delete > kindToken = < name > "." propertyToken = < name >  {    String propertyName = propertyToken.toString();    String kind = kindToken.toString();    ArrayList < String > schema = getCurrentSchema(kind);    if (schema == null)    {      throw new InputMismatchException("no info for schema of " + kind + " found");    }    if (!propertyExists(kind, propertyName))    {      throw new InputMismatchException("attribute for " + kind + " does not exist");    }    ArrayList < String > newSchema = getNewSchemaDelete(kind, propertyName);    int currentVersion = getCurrentSchemaVersion(kind);    int newVersion = currentVersion + 1;    String residualRules = getResidualRules(kind);    String headRules = kind + newVersion + "(" + schemaToString(newSchema) + "," + getTimestamp() + "):-" + kind + currentVersion + "(" + schemaToString(schema) + ",?ts), latest" + kind + currentVersion + "(?id,?ts).\n";    saveCurrentSchema(kind, newSchema);    rules.addAll((new ParserRuleToJava(new StringReader(residualRules))).start());    rules.addAll((new ParserRuleToJava(new StringReader(headRules))).parseHeadRules());    return residualRules + headRules;  }}String copy() throws InputMismatchException, IOException, parserRuletoJava.ParseException :{  Token kindFromToken = null;  Token kindToToken = null;  Token propertyToken = null;  Token conditionFromToken = null;  Token conditionToToken = null;}{  < copy > kindFromToken = < name > "." propertyToken = < name > " to " kindToToken = < name > " where " kindFromToken = < name > "." conditionFromToken = < name > "=" kindToToken = < name > "." conditionToToken = < name >  {    String kindFrom = kindFromToken.toString();    String kindTo = kindToToken.toString();    String attribute = propertyToken.toString();    String conditionFrom = conditionFromToken.toString();    String conditionTo = conditionToToken.toString();    String residualRules = getResidualRules(kindFrom) + getResidualRules(kindTo);    ArrayList < String > schemaFrom = getCurrentSchema(kindFrom);    ArrayList < String > schemaTo = getCurrentSchema(kindTo);    if (schemaFrom == null)    {      throw new InputMismatchException("no info for schema of " + kindFrom + " found");    }    if (schemaTo == null)    {      throw new InputMismatchException("no info for schema of " + kindTo + " found");    }    if (!propertyExists(kindFrom, attribute))    {      throw new InputMismatchException("attribute: " + attribute + " for " + kindFrom + " does not exist");    }    if (!propertyExists(kindFrom, conditionFrom))    {      throw new InputMismatchException("attribute: " + conditionFrom + " for " + kindFrom + " does not exist");    }    if (!propertyExists(kindTo, conditionTo))    {      throw new InputMismatchException("attribute: " + conditionTo + " for " + kindTo + " does not exist");    }    if (propertyExists(kindTo, attribute))    {      throw new InputMismatchException("attribute: " + attribute + " for " + kindTo + " already exists");    }    ArrayList < String > schemaToNew = getNewSchemaAdd(kindTo, "?" + attribute);    ArrayList < String > schemaToNew2 = getNewSchemaAdd(kindTo, "null");    int currentSchemaVersionTo = getCurrentSchemaVersion(kindTo);    int currentSchemaVersionFrom = getCurrentSchemaVersion(kindFrom);    int newSchemaVersionTo = currentSchemaVersionTo + 1;    saveCurrentSchema(kindTo, schemaToNew);    schemaToNew = addAttributeNr(schemaToNew, 1, "?" + attribute);    schemaToNew2 = addAttributeNr(schemaToNew2, 1, "");    schemaTo = addAttributeNr(schemaTo, 1, "");    schemaFrom = addAttributeNr(schemaFrom, 2, "");    String condition = "?" + conditionFrom + "2 = " + "?" + conditionTo + "1";    String headRules = kindTo + newSchemaVersionTo + "(" + schemaToString(schemaToNew) + "," + getTimestamp() + "):-" + kindTo + currentSchemaVersionTo + "(" + schemaToString(schemaTo) + ",?ts1),latest" + kindTo + currentSchemaVersionTo + "(?id1,?ts1)," + kindFrom + currentSchemaVersionFrom + "(" + schemaToString(schemaFrom) + ",?ts2), latest" + kindFrom + currentSchemaVersionFrom + "(?id2,?ts2)," + condition + ".\n";    headRules = headRules + kindTo + newSchemaVersionTo + "(" + schemaToString(schemaToNew2) + "," + getTimestamp() + "):-" + kindTo + currentSchemaVersionTo + "(" + schemaToString(schemaTo) + ",?ts1),latest" + kindTo + currentSchemaVersionTo + "(?id1,?ts1)," + " not " + kindFrom + currentSchemaVersionFrom + "(" + schemaToString(schemaFrom) + ",?ts2)," + condition + ".\n";    rules.addAll((new ParserRuleToJava(new StringReader(residualRules))).start());    rules.addAll((new ParserRuleToJava(new StringReader(headRules))).parseHeadRules());    return residualRules + headRules;  }}String move() throws InputMismatchException, IOException, parserRuletoJava.ParseException :{  Token kindFromToken = null;  Token kindToToken = null;  Token propertyToken = null;  Token conditionFromToken = null;  Token conditionToToken = null;}{  < move > kindFromToken = < name > "." propertyToken = < name > " to " kindToToken = < name > " where " kindFromToken = < name > "." conditionFromToken = < name > "=" kindToToken = < name > "." conditionToToken = < name >  {    String kindFrom = kindFromToken.toString();    String kindTo = kindToToken.toString();    String attribute = propertyToken.toString();    String conditionFrom = conditionFromToken.toString();    String conditionTo = conditionToToken.toString();    String residualRules = getResidualRules(kindFrom) + getResidualRules(kindTo);    ArrayList < String > schemaFrom = getCurrentSchema(kindFrom);    ArrayList < String > schemaTo = getCurrentSchema(kindTo);    if (schemaFrom == null)    {      throw new InputMismatchException("no info for schema of " + kindFrom + " found");    }    if (schemaTo == null)    {      throw new InputMismatchException("no info for schema of " + kindTo + " found");    }    if (!propertyExists(kindFrom, attribute))    {      throw new InputMismatchException("attribute: " + attribute + " for " + kindFrom + " does not exist");    }    if (!propertyExists(kindFrom, conditionFrom))    {      throw new InputMismatchException("attribute: " + conditionFrom + " for " + kindFrom + " does not exist");    }    if (!propertyExists(kindTo, conditionTo))    {      throw new InputMismatchException("attribute: " + conditionTo + " for " + kindTo + " does not exist");    }    if (propertyExists(kindTo, attribute))    {      throw new InputMismatchException("attribute: " + attribute + " for " + kindTo + " already exists");    }    ArrayList < String > schemaFromNew = getNewSchemaDelete(kindFrom, attribute);    ArrayList < String > schemaToNew = getNewSchemaAdd(kindTo, "?" + attribute);    ArrayList < String > schemaToNew2 = getNewSchemaAdd(kindTo, "null");    int currentSchemaVersionFrom = getCurrentSchemaVersion(kindFrom);    int newSchemaVersionFrom = currentSchemaVersionFrom + 1;    int currentSchemaVersionTo = getCurrentSchemaVersion(kindTo);    int newSchemaVersionTo = currentSchemaVersionTo + 1;    saveCurrentSchema(kindFrom, schemaFromNew);    saveCurrentSchema(kindTo, schemaToNew);    schemaToNew = addAttributeNr(schemaToNew, 1, "?" + attribute);    schemaToNew2 = addAttributeNr(schemaToNew2, 1, "");    schemaTo = addAttributeNr(schemaTo, 1, "");    schemaFrom = addAttributeNr(schemaFrom, 2, "");    schemaFromNew = addAttributeNr(schemaFromNew, 2, "");    String condition = "?" + conditionFrom + "2 = " + "?" + conditionTo + "1";    String headRules = kindTo + newSchemaVersionTo + "(" + schemaToString(schemaToNew) + "," + getTimestamp() + "):-" + kindTo + currentSchemaVersionTo + "(" + schemaToString(schemaTo) + ",?ts1),latest" + kindTo + currentSchemaVersionTo + "(?id1,?ts1)," + kindFrom + currentSchemaVersionFrom + "(" + schemaToString(schemaFrom) + ",?ts2), latest" + kindFrom + currentSchemaVersionFrom + "(?id2,?ts2)," + condition + ".\n";    headRules = headRules + kindTo + newSchemaVersionTo + "(" + schemaToString(schemaToNew2) + "," + getTimestamp() + "):-" + kindTo + currentSchemaVersionTo + "(" + schemaToString(schemaTo) + ",?ts1),latest" + kindTo + currentSchemaVersionTo + "(?id1,?ts1)," + " not " + kindFrom + currentSchemaVersionFrom + "(" + schemaToString(schemaFrom) + ",?ts2)," + condition + ".\n";    headRules = headRules + kindFrom + newSchemaVersionFrom + "(" + schemaToString(schemaFromNew) + "," + getTimestamp() + "):-" + kindFrom + currentSchemaVersionFrom + "(" + schemaToString(schemaFrom) + ",?ts2), latest" + kindFrom + currentSchemaVersionFrom + "(?id2,?ts2).\n";    rules.addAll((new ParserRuleToJava(new StringReader(residualRules))).start());    rules.addAll((new ParserRuleToJava(new StringReader(headRules))).parseHeadRules());    return residualRules + headRules;  }}