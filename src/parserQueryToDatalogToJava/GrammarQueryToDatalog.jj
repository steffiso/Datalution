/**
 * JavaCC template file created by SF JavaCC plugin 1.5.28+ wizard for JavaCC 1.5.0+
 */options{  static = false;}PARSER_BEGIN(ParserQueryToDatalogToJava)package parserQueryToDatalogToJava;import java.util.ArrayList;import java.io.StringReader;import datastore.DatalutionDatastoreService;import datastore.Schema;import datalog.Rule;import parserRuletoJava.ParserRuleToJava;import java.util.InputMismatchException;import java.io.IOException;import com.google.appengine.api.datastore.EntityNotFoundException;public class ParserQueryToDatalogToJava{  private String kindStr;  private String idStr;  private int id;  private String rulesStr;  private static DatalutionDatastoreService dds;  private static ArrayList < Rule > rules = new ArrayList < Rule > ();  private static Schema currentSchemaFrom = null;  private static Schema currentSchemaTo = null;  public String getKind()  {    return kindStr;  }  public String getIdStr()  {    return idStr;  }  public int getId()  {    return id;  }  public String getRules()  {    return rulesStr;  }  private static void getSchemaFromDB(String kindFrom, String kindTo) throws InputMismatchException, IOException, EntityNotFoundException  {    if (!kindFrom.equals("")) currentSchemaFrom = getCurrentSchema(kindFrom);    if (!kindTo.equals("")) currentSchemaTo = getCurrentSchema(kindTo);  }  private static Schema getCurrentSchema(String kind) throws InputMismatchException, IOException, EntityNotFoundException  {    Schema currentSchema = dds.getLatestSchema(kind);    if (currentSchema != null) return currentSchema;    else return null;  }  private static String schemaToString(ArrayList < String > schema)  {    String schemaStr = "";    for (String s : schema)    {      schemaStr = schemaStr + s + ",";    }    schemaStr = schemaStr.substring(0, schemaStr.length() - 1);    return schemaStr;  }  private static ArrayList < String > addAttributeNr(ArrayList < String > schema, int nr, String copiedAttr)  {    ArrayList < String > changedSchema = new ArrayList < String > ();    for (String s : schema)    {      if (!s.equals("null"))      {        if (s.equals(copiedAttr)) changedSchema.add(s + "2");        else changedSchema.add(s + Integer.toString(nr));      }      else changedSchema.add(s);    }    return changedSchema;  }  private static ArrayList < String > getNewSchemaDelete(String kind, String value) throws InputMismatchException, IOException  {    ArrayList < String > currentSchemaAttributes = null;    if (currentSchemaFrom.getKind().equals(kind))     currentSchemaAttributes = currentSchemaFrom.getAttributesAsList();    else if (currentSchemaTo.getKind().equals(kind))     currentSchemaAttributes = currentSchemaTo.getAttributesAsList();    if (currentSchemaAttributes == null)    {      throw new InputMismatchException("no info for schema of " + kind + " found");    }    else    {      ArrayList < String > tempNewSchema = new ArrayList < String > ();      for (String attribute : currentSchemaAttributes)      {        if (!attribute.equals("?" + value)) tempNewSchema.add(attribute);      }      return tempNewSchema;    }  }  private static ArrayList < String > getNewSchemaAdd(String kind, String value) throws InputMismatchException, IOException  {    ArrayList < String > currentSchemaAttributes = null;    if (currentSchemaFrom.getKind().equals(kind)) currentSchemaAttributes = currentSchemaFrom.getAttributesAsList();    else if (currentSchemaTo.getKind().equals(kind)) currentSchemaAttributes = currentSchemaTo.getAttributesAsList();    if (currentSchemaAttributes == null)    {      throw new InputMismatchException("no info for schema of " + kind + " found");    }    else    {      currentSchemaAttributes.add(value);      return currentSchemaAttributes;    }  }  private static void saveCurrentSchema(String kind, ArrayList < String > newSchema) throws InputMismatchException, IOException, EntityNotFoundException  {    ArrayList < String > currentSchemaAttributes = null;    if (currentSchemaFrom.getKind().equals(kind)) currentSchemaAttributes = currentSchemaFrom.getAttributesAsList();    else if (currentSchemaTo.getKind().equals(kind)) currentSchemaAttributes = currentSchemaTo.getAttributesAsList();    if (currentSchemaAttributes == null)    {      throw new InputMismatchException("no info for schema of " + kind + " found");    }    else    {      dds.saveCurrentSchema(kind, newSchema);    }  }  public String getAttributeName(String kind, int schemaNumber, int pos) throws InputMismatchException, IOException, EntityNotFoundException  {    Schema currentSchema = dds.getSchema(kind, schemaNumber);    if (currentSchema != null)    {      ArrayList < String > attributes = currentSchema.getAttributesAsList();      String value = attributes.get(pos);      return value;    }    else    {      throw new InputMismatchException("no info for schema of " + kind + " found");    }  }  private static boolean propertyExists(Schema schema, String value) throws InputMismatchException, IOException  {    return schema.getAttributesAsList().contains("?" + value);  }}PARSER_END(ParserQueryToDatalogToJava)SKIP :{  " "| "\r"| "\t"| "\n"}TOKEN :{  < get : "get" >| < add : "add" >| < delete : "delete" >| < copy : "copy" >| < move : "move" >| < string : "\"" (~[ "\"" ])* "\"" >| < nullValue : "null" >| < number :    (< digit >)+    (      "." (< digit >)+    )? >| < digit : [ "0"-"9" ] >| < name : < nameValue > (< nameValue >)* >| < nameValue :    [ "a"-"z" ]  | [ "A"-"Z" ]  | "_" >}String getDatalogRules(DatalutionDatastoreService dds) throws InputMismatchException, IOException, parserRuletoJava.ParseException, EntityNotFoundException :{  String value = null;  this.dds = dds;}{  value = start() < EOF >  {    return value;  }}ArrayList < Rule > getJavaRules(DatalutionDatastoreService dds) throws InputMismatchException, IOException, parserRuletoJava.ParseException, EntityNotFoundException :{  String value = null;  this.dds = dds;}{  value = start() < EOF >  {    rulesStr = value;    return rules;  }}String start() throws InputMismatchException, IOException, parserRuletoJava.ParseException, EntityNotFoundException :{  String value = null;  rules = new ArrayList < Rule > ();  currentSchemaFrom = null;  currentSchemaTo = null;}{  (    value = get()  | value = add()  | value = delete()  | value = copy()  | value = move()  )  {    return value;  }}String get() throws IOException, parserRuletoJava.ParseException, EntityNotFoundException :{  Token kindToken = null;  Token idToken = null;  Token propertyToken = null;}{  < get > kindToken = < name > "." propertyToken = < name > "="  (    idToken = < string >  | idToken = < number >  )  {    if (!propertyToken.toString().equals("id")) throw new IOException("only id for get");    String kind = kindToken.toString();    String idTemp;    if (idToken.kind == string)    {      idTemp = idToken.toString();      idTemp = idTemp.substring(1, idTemp.length() - 1);      idTemp = "'" + idTemp + "'";    }    else    {      idTemp = idToken.toString();      id = Integer.parseInt(idToken.toString());    }    kindStr = kind;    idStr = idTemp;    getSchemaFromDB(kind, "");    if (currentSchemaFrom == null)    {      throw new InputMismatchException("no info for schema of " + kind + " found");    }    ArrayList < String > schema = currentSchemaFrom.getAttributesAsList();    int currentVersion = currentSchemaFrom.getVersion();    String headRule = "get" + kind + currentVersion + "(" + schemaToString(schema) + ",?ts):-$"     + kind + currentVersion + "(" + schemaToString(schema) + ",?ts),?id=" + id + ".\n";    rules.addAll((new ParserRuleToJava(new StringReader(headRule))).parseHeadRules());    return headRule;  }}String add() throws InputMismatchException, IOException, parserRuletoJava.ParseException, EntityNotFoundException :{  Token kindToken = null;  Token propertyToken = null;  Token valueToken = null;}{  < add > kindToken = < name > "." propertyToken = < name > "="  (    valueToken = < string >  | valueToken = < number >  | valueToken = < nullValue >  )  {    String propertyName = propertyToken.toString();    String propertyValue;    if (valueToken.kind == string)    {      propertyValue = valueToken.toString();      propertyValue = propertyValue.substring(1, propertyValue.length() - 1);      propertyValue = "'" + propertyValue + "'";    }    else propertyValue = valueToken.toString();    String kind = kindToken.toString();    getSchemaFromDB(kind, "");    if (currentSchemaFrom == null)    {      throw new InputMismatchException("no info for schema of " + kind + " found");    }    if (propertyExists(currentSchemaFrom, propertyName))    {      throw new InputMismatchException("attribute for " + kind + " already exists");    }    ArrayList < String > currentSchema = currentSchemaFrom.getAttributesAsList();    ArrayList < String > newSchema = getNewSchemaAdd(kind, "?" + propertyName);    int currentSchemaVersion = currentSchemaFrom.getVersion();    int newSchemaVersion = currentSchemaVersion + 1;    String headRules = kind + newSchemaVersion + "(" + schemaToString(getNewSchemaAdd(kind, propertyValue)) + ",?ts):-$"     + kind + currentSchemaVersion + "(" + schemaToString(currentSchema) + ",?ts).\n";    saveCurrentSchema(kind, newSchema);    rules.addAll((new ParserRuleToJava(new StringReader(headRules))).parseHeadRules());    return headRules;  }}String delete() throws InputMismatchException, IOException, parserRuletoJava.ParseException, EntityNotFoundException :{  Token kindToken = null;  Token propertyToken = null;}{  < delete > kindToken = < name > "." propertyToken = < name >  {    String propertyName = propertyToken.toString();    String kind = kindToken.toString();    getSchemaFromDB(kind, "");    if (currentSchemaFrom == null)    {      throw new InputMismatchException("no info for schema of " + kind + " found");    }    if (!propertyExists(currentSchemaFrom, propertyName))    {      throw new InputMismatchException("attribute for " + kind + " does not exist");    }    ArrayList < String > newSchema = getNewSchemaDelete(kind, propertyName);    int currentVersion = currentSchemaFrom.getVersion();    int newVersion = currentVersion + 1;    String headRules = kind + newVersion + "(" + schemaToString(newSchema) + ",?ts):-$"     + kind + currentVersion + "(" + schemaToString(currentSchemaFrom.getAttributesAsList()) + ",?ts).\n";    saveCurrentSchema(kind, newSchema);    rules.addAll((new ParserRuleToJava(new StringReader(headRules))).parseHeadRules());    return headRules;  }}String copy() throws InputMismatchException, IOException, parserRuletoJava.ParseException, EntityNotFoundException :{  Token kindFromToken = null;  Token kindToToken = null;  Token propertyToken = null;  Token condKind1Token = null;  Token condKind2Token = null;  Token condProp1Token = null;  Token condProp2Token = null;}{  < copy > kindFromToken = < name > "." propertyToken = < name > " to " kindToToken = < name > " where " condKind1Token = < name > "." condProp1Token = < name > "=" condKind2Token = < name > "." condProp2Token = < name >  {    String kindFrom = kindFromToken.toString();    String kindTo = kindToToken.toString();    String attribute = propertyToken.toString();    getSchemaFromDB(kindFrom, kindTo);    if (currentSchemaFrom == null)    {      throw new InputMismatchException("no info for schema of " + kindFrom + " found");    }    if (currentSchemaTo == null)    {      throw new InputMismatchException("no info for schema of " + kindTo + " found");    }    if (!propertyExists(currentSchemaFrom, attribute))    {      throw new InputMismatchException("attribute: " + attribute + " for " + kindFrom + " does not exist");    }    String condKind1 = condKind1Token.toString();    String condKind2 = condKind2Token.toString();    String condProp1 = condProp1Token.toString();    String condProp2 = condProp2Token.toString();    String conditionFrom = "";    String conditionTo = "";    if (condKind1.equals(kindTo)) conditionTo = condProp1;    else if (condKind1.equals(kindFrom)) conditionFrom = condProp1;    else    {      throw new InputMismatchException("No matching source for condition " + condKind1 + "." + condProp1);    }    if (condKind2.equals(kindFrom)) conditionFrom = condProp2;    else if (condKind2.equals(kindTo)) conditionTo = condProp2;    else    {      throw new InputMismatchException("No matching source for condition " + condKind2 + "." + condProp2);    }    if (!propertyExists(currentSchemaFrom, conditionFrom))    {      throw new InputMismatchException("attribute: " + conditionFrom + " for " + kindFrom + " does not exist");    }    if (!propertyExists(currentSchemaTo, conditionTo))    {      throw new InputMismatchException("attribute: " + conditionTo + " for " + kindTo + " does not exist");    }    if (propertyExists(currentSchemaTo, attribute))    {      throw new InputMismatchException("attribute: " + attribute + " for " + kindTo + " already exists");    }    ArrayList < String > schemaToNew = getNewSchemaAdd(kindTo, "?" + attribute);    ArrayList < String > schemaToNew2 = getNewSchemaAdd(kindTo, "null");    saveCurrentSchema(kindTo, schemaToNew);    saveCurrentSchema(kindFrom, currentSchemaFrom.getAttributesAsList());    int currentSchemaVersionTo = currentSchemaTo.getVersion();    int currentSchemaVersionFrom = currentSchemaFrom.getVersion();    int newSchemaVersionTo = currentSchemaVersionTo + 1;    int newSchemaVersionFrom = currentSchemaVersionFrom + 1;    schemaToNew = addAttributeNr(schemaToNew, 1, "?" + attribute);    schemaToNew2 = addAttributeNr(schemaToNew2, 1, "");    ArrayList < String > schemaTo = addAttributeNr(currentSchemaTo.getAttributesAsList(), 1, "");    ArrayList < String > schemaFrom = addAttributeNr(currentSchemaFrom.getAttributesAsList(), 2, "");    String condition = "?" + conditionFrom + "2 = " + "?" + conditionTo + "1";    String headRules = kindTo + newSchemaVersionTo + "(" + schemaToString(schemaToNew) + ",?ts1):-$"     + kindTo + currentSchemaVersionTo + "(" + schemaToString(schemaTo) + ",?ts1),$"     + kindFrom + currentSchemaVersionFrom + "(" + schemaToString(schemaFrom) + ",?ts2)," + condition + ".\n";    headRules = headRules + kindTo + newSchemaVersionTo + "(" + schemaToString(schemaToNew2) + ",?ts1):-$"     + kindTo + currentSchemaVersionTo + "(" + schemaToString(schemaTo) + ",?ts1)," +     " not $" + kindFrom + currentSchemaVersionFrom + "(" + schemaToString(schemaFrom) + ",?ts2)," + condition + ".\n";    headRules = headRules + kindFrom + newSchemaVersionFrom + "(" + schemaToString(schemaFrom) + ",?ts2):-$"     + kindFrom + currentSchemaVersionFrom + "(" + schemaToString(schemaFrom) + ",?ts2).\n";    rules.addAll((new ParserRuleToJava(new StringReader(headRules))).parseHeadRules());    return headRules;  }}String move() throws InputMismatchException, IOException, parserRuletoJava.ParseException, EntityNotFoundException :{  Token kindFromToken = null;  Token kindToToken = null;  Token propertyToken = null;  Token condKind1Token = null;  Token condKind2Token = null;  Token condProp1Token = null;  Token condProp2Token = null;}{  < move > kindFromToken = < name > "." propertyToken = < name > " to " kindToToken = < name > " where " condKind1Token = < name > "." condProp1Token = < name > "=" condKind2Token = < name > "." condProp2Token = < name >  {    String kindFrom = kindFromToken.toString();    String kindTo = kindToToken.toString();    String attribute = propertyToken.toString();    getSchemaFromDB(kindFrom, kindTo);    if (currentSchemaFrom == null)    {      throw new InputMismatchException("no info for schema of " + kindFrom + " found");    }    if (currentSchemaTo == null)    {      throw new InputMismatchException("no info for schema of " + kindTo + " found");    }    if (!propertyExists(currentSchemaFrom, attribute))    {      throw new InputMismatchException("attribute: " + attribute + " for " + kindFrom + " does not exist");    }    String condKind1 = condKind1Token.toString();    String condKind2 = condKind2Token.toString();    String condProp1 = condProp1Token.toString();    String condProp2 = condProp2Token.toString();    String conditionFrom = "";    String conditionTo = "";    if (condKind1.equals(kindTo)) conditionTo = condProp1;    else if (condKind1.equals(kindFrom)) conditionFrom = condProp1;    else    {      throw new InputMismatchException("No matching source for condition " + condKind1 + "." + condProp1);    }    if (condKind2.equals(kindFrom))     conditionFrom = condProp2;    else if (condKind2.equals(kindTo))     conditionTo = condProp2;    else    {      throw new InputMismatchException("No matching source for condition " + condKind2 + "." + condProp2);    }    if (!propertyExists(currentSchemaFrom, conditionFrom))    {      throw new InputMismatchException("attribute: " + conditionFrom + " for " + kindFrom + " does not exist");    }    if (!propertyExists(currentSchemaTo, conditionTo))    {      throw new InputMismatchException("attribute: " + conditionTo + " for " + kindTo + " does not exist");    }    if (propertyExists(currentSchemaTo, attribute))    {      throw new InputMismatchException("attribute: " + attribute + " for " + kindTo + " already exists");    }    ArrayList < String > schemaFromNew = getNewSchemaDelete(kindFrom, attribute);    ArrayList < String > schemaToNew = getNewSchemaAdd(kindTo, "?" + attribute);    ArrayList < String > schemaToNew2 = getNewSchemaAdd(kindTo, "null");    saveCurrentSchema(kindFrom, schemaFromNew);    saveCurrentSchema(kindTo, schemaToNew);    int currentSchemaVersionFrom = currentSchemaFrom.getVersion();    int currentSchemaVersionTo = currentSchemaTo.getVersion();    int newSchemaVersionFrom = currentSchemaVersionFrom + 1;    int newSchemaVersionTo = currentSchemaVersionTo + 1;    schemaToNew = addAttributeNr(schemaToNew, 1, "?" + attribute);    schemaToNew2 = addAttributeNr(schemaToNew2, 1, "");    ArrayList < String > schemaTo = addAttributeNr(currentSchemaTo.getAttributesAsList(), 1, "");    ArrayList < String > schemaFrom = addAttributeNr(currentSchemaFrom.getAttributesAsList(), 2, "");    schemaFromNew = addAttributeNr(schemaFromNew, 2, "");    String condition = "?" + conditionFrom + "2 = " + "?" + conditionTo + "1";    String headRules = kindTo + newSchemaVersionTo + "(" + schemaToString(schemaToNew) + ",?ts1):-$"     + kindTo + currentSchemaVersionTo + "(" + schemaToString(schemaTo) + ",?ts1),$"     + kindFrom + currentSchemaVersionFrom + "(" + schemaToString(schemaFrom) + ",?ts2)," + condition + ".\n";    headRules = headRules + kindTo + newSchemaVersionTo + "(" + schemaToString(schemaToNew2) + ",?ts1):-$"     + kindTo + currentSchemaVersionTo + "(" + schemaToString(schemaTo) + ",?ts1)," +     " not $" + kindFrom + currentSchemaVersionFrom + "(" + schemaToString(schemaFrom) + ",?ts2)," + condition + ".\n";    headRules = headRules + kindFrom + newSchemaVersionFrom + "(" + schemaToString(schemaFromNew) + ",?ts2):-$"     + kindFrom + currentSchemaVersionFrom + "(" + schemaToString(schemaFrom) + ",?ts2).\n";    rules.addAll((new ParserRuleToJava(new StringReader(headRules))).parseHeadRules());    return headRules;  }}