/**
 * JavaCC template file created by SF JavaCC plugin 1.5.28+ wizard for JavaCC 1.5.0+
 *
 * This parser generates the entity which needs to be put to Datastore.
 * This put command can be triggered from Lazy Migration automatically,
 * as well as through a manual put within the user console.
 */options{  static = false;}PARSER_BEGIN(ParserForGet)package parserGetToDatalog;import java.util.ArrayList;
import java.io.StringReader;
import datastore.DatalutionDatastoreService;
import datastore.Schema;
import datalog.Rule;
import parserRuletoJava.ParserRuleToJava;
import java.util.InputMismatchException;
import java.io.IOException;
import com.google.appengine.api.datastore.EntityNotFoundException;
public class ParserForGet{   private String kindStr;

  private String idStr;

  private int id;

  private String rulesStr;

  private static DatalutionDatastoreService dds;

  private ArrayList < Rule > rules = new ArrayList < Rule > ();

  private static Schema currentSchemaFrom = null;

  public String getKind()
  {
    return kindStr;
  }

  public String getIdStr()
  {
    return idStr;
  }

  public int getId()
  {
    return id;
  }

  public String getRules()
  {
    return rulesStr;
  }

  private static void getSchemaFromDB(String kind) throws InputMismatchException, IOException, EntityNotFoundException
  {
    currentSchemaFrom = getCurrentSchema(kind);
  }

  private static Schema getCurrentSchema(String kind) throws InputMismatchException, IOException, EntityNotFoundException
  {
    Schema currentSchema = dds.getLatestSchema(kind);
    if (currentSchema != null) return currentSchema;
    else return null;
  }

    private static String schemaToString(ArrayList < String > schema)
  {
    String schemaStr = "";
    for (String s : schema)
    {
      schemaStr = schemaStr + s + ",";
    }
    schemaStr = schemaStr.substring(0, schemaStr.length() - 1);
    return schemaStr;
  }}PARSER_END(ParserForGet)SKIP :{  " "| "\r"| "\t"| "\n"}TOKEN :
{
  < get : "get" >
| < string : "\"" (~[ "\"" ])* "\"" >
| < nullValue : "null" >
| < number :
    (< digit >)+
    (
      "." (< digit >)+
    )? >
| < digit : [ "0"-"9" ] >
| < name : < nameValue > (< nameValue >)* >
| < nameValue :
    [ "a"-"z" ]
  | [ "A"-"Z" ]
  | "_" >
}void setAttributes() throws InputMismatchException, EntityNotFoundException, IOException, parserRuletoJava.ParseException :{}{  get(false) < EOF >  {  }}

ArrayList < Rule > getJavaRules(DatalutionDatastoreService dds) throws InputMismatchException, IOException, parserRuletoJava.ParseException, EntityNotFoundException :
{
  ParserForGet.dds = dds;
}
{
  get(true) < EOF >
  {
    return rules;
  }
}

void get(Boolean check) throws IOException, parserRuletoJava.ParseException, EntityNotFoundException :
{
  Token kindToken = null;
  Token idToken = null;
  Token propertyToken = null;
}
{
  < get > kindToken = < name > "." propertyToken = < name > "="
  (
    idToken = < string >
  | idToken = < number >
  )
  {
    if (!propertyToken.toString().equals("id")) throw new IOException("only id for get");
    String kind = kindToken.toString();
    String idTemp;
    if (idToken.kind == string)
    {
      idTemp = idToken.toString();
      idTemp = idTemp.substring(1, idTemp.length() - 1);
      idTemp = "'" + idTemp + "'";
    }
    else
    {
      idTemp = idToken.toString();
      id = Integer.parseInt(idToken.toString());
    }
    kindStr = kind;
    idStr = idTemp;
    if(check)    {      
    getSchemaFromDB(kind);
    if (currentSchemaFrom == null)
    {
      throw new InputMismatchException("no info for schema of " + kind + " found");
    }
    ArrayList < String > schema = currentSchemaFrom.getAttributesAsList();
    int currentVersion = currentSchemaFrom.getVersion();
    String headRule = "get" + kind + currentVersion + "(" + schemaToString(schema) + ",?ts):-$" 
    + kind + currentVersion + "(" + schemaToString(schema) + ",?ts),?id=" + id + ".\n";
   	rules.addAll((new ParserRuleToJava(new StringReader(headRule))).parseHeadRules());  }  
  }
}